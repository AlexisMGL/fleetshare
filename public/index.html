<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AerialMetric fleet follow</title>

    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #windy {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
        }

        #loading {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="windy"></div>
    <div id="loading">Loading</div>

    <script>
        let windy_options = {
            key: 'SSUGxhvXMZUTgav1QfuYZG7smD3vaEPB',
            lat: 14,
            lon: -29,
            zoom: 15
        };

        let init_done = false;
        let map = null;
        let options = null;

        // Initialisation locale d'options si aucun message externe n'est reçu
        if (!options) {
            options = {
                key: windy_options.key,
                autoPan: true,
                trailLengthM: 10000
            };
        }

        function init() {
            if (!options) {
                setTimeout(init, 100);
                return;
            }
            const loading_div = document.getElementById("loading");
            if (!options.key) {
                loading_div.innerHTML = "Please set API key";
                setTimeout(init, 100);
                return;
            }
            if (!init_done) {
                windy_options.key = options.key;
                init_done = true;
                windyInit(windy_options, windyAPI => {
                    map = windyAPI.map;
                    map.options.maxZoom = 17;
                    loading_div.style.display = "none";

                    // force le calque "wind"
                    windyAPI.store.set("overlay", "wind");

                    // attribution Windy.com
                    map.attributionControl.addAttribution(
                        'Données météo © <a href="https://www.windy.com" target="_blank">Windy.com</a>'
                    );

                    // redessiner et déclencher zoomend pour rafraîchir l’UI
                    setTimeout(() => {
                        map.invalidateSize();
                        map.fire("zoomend");
                    }, 500);

                    // cercles
                    L.circle([-23.3470407, 47.5962614], {
                        color: 'red',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-22.91202751744944, 44.528044921900346], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-19.672116, 47.314187], {
                        color: 'green',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                });
            }
            if (!map) {
                loading_div.innerHTML = "Waiting for map";
                setTimeout(init, 100);
                return;
            }
            loading_div.style.display = "none";

            const topLayer = L.tileLayer(
                'http://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                {
                    attribution: 'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping',
                    minZoom: 12,
                    maxZoom: 17
                }
            ).addTo(map);
            topLayer.setOpacity(0);
            map.on('zoomend', () => {
                topLayer.setOpacity(map.getZoom() >= 12 ? 1 : 0);
            });

            map.setView([-18.91368, 47.53613], 7);
            L.control.scale().addTo(map);
        }

        setTimeout(init, 100);

        // Add new vehicle to map
        let vehicle = [];
        function vehicle_init(id, location, msg) {
            const vehicle_icon = L.divIcon({
                html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                   <path fill="#000" d="M482.3 192c34.2 0 93.7 29 93.7 64c0 36-59.5 64-93.7 64l-116.6 0L265.2 495.9c-5.7 10-16.3 16.1-27.8 16.1l-56.2 0c-10.6 0-18.3-10.2-15.4-20.4l49-171.6L112 320 68.8 377.6c-3 4-7.8 6.4-12.8 6.4l-42 0c-7.8 0-14-6.3-14-14c0-1.3 .2-2.6 .5-3.9L32 256 .5 145.9c-.4-1.3-.5-2.6-.5-3.9c0-7.8 6.3-14 14-14l42 0c5 0 9.8 2.4 12.8 6.4L112 192l102.9 0-49-171.6C162.9 10.2 170.6 0 181.2 0l56.2 0c11.5 0 22.1 6.2 27.8 16.1L365.7 192l116.6 0z"/>
                 </svg>`,
                className: "",
                iconSize: [50, 44]
            });
            const marker = new L.marker(location, {
                icon: vehicle_icon,
                rotationOrigin: "center",
                zIndexOffset: 10000,
                interactive: true
            }).addTo(map);

            // Tooltip permanent, une seule fois
            let tooltip = `SN${msg.sysid ?? id}`;
            marker.bindTooltip(tooltip, {
                permanent: true,
                direction: "right",
                offset: [20, 0],
                className: "vehicle-tooltip"
            });

            // Gestion du survol : change dynamiquement le contenu du tooltip
            marker.on('mouseover', function () {
                let hoverTooltip = `SN${msg.sysid ?? id}`;
                if (msg.airspeed !== undefined && msg.groundspeed !== undefined) {
                    hoverTooltip += `<br><span style="font-size:12px;">as = ${msg.airspeed} gs = ${msg.groundspeed}</span>`;
                }
                this.setTooltipContent(hoverTooltip);
            });
            marker.on('mouseout', function () {
                this.setTooltipContent(`SN${msg.sysid ?? id}`);
            });

            const trail = new L.polyline([location], {
                color: "yellow",
                interactive: false
            }).addTo(map);
            vehicle[id] = { marker, trail };
            map.panTo(location);
        }

        function update_pos(msg) {
            // Vérifie que lat et lon existent et sont des nombres
            if (typeof msg.lat !== "number" || typeof msg.lon !== "number") {
                console.warn("update_pos ignoré : lat/lon manquants", msg);
                return;
            }
            const id = msg.sysid ?? 1;
            const location = new L.LatLng(msg.lat, msg.lon);
            const heading = msg.yaw || 0;
            if (!vehicle[id]) {
                vehicle_init(id, location, msg);
            }
            if ("setRotationAngle" in vehicle[id].marker) {
                vehicle[id].marker.setRotationAngle(heading - 90.0);
            }
            vehicle[id].marker.setLatLng(location);

            // Met à jour le contenu du tooltip permanent (hors survol)
            vehicle[id].marker.setTooltipContent(`SN${msg.sysid ?? id}`);

            if (options.autoPan) {
                map.panInside(location, { padding: [50, 50] });
            }
            const trail = vehicle[id].trail.getLatLngs();
            trail.unshift(location);
            let length = 0;
            for (let i = 1; i < trail.length; i++) {
                length += trail[i - 1].distanceTo(trail[i]);
                if (length > options.trailLengthM) {
                    trail.splice(i);
                    break;
                }
            }
            vehicle[id].trail.setLatLngs(trail);
        }


        // Add home to the map
        let home = [];
        function home_init(id, location) {
            const icon_div = document.createElement("div");
            icon_div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                                    <path fill="#fff" d="M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/>
                                 </svg>`;
            const home_icon = L.divIcon({ html: icon_div, className: "", iconSize: [40, 36] });
            home[id] = new L.marker(location, { icon: home_icon, interactive: false }).addTo(map);
        }
        function update_home(msg) {
            const id = msg._header.srcSystem;
            const location = new L.LatLng(msg.latitude * 1e-7, msg.longitude * 1e-7);
            if (!home[id]) home_init(id, location);
            home[id].setLatLng(location);
        }

        // Nav target line
        function update_nav_target(msg) { /* ... same as before ... */ }
        // Position target line
        function update_position_target(msg) { /* ... same as before ... */ }

        // Runtime function
        function handle_msg(msg) {
            if (!map || msg._header.srcComponent !== 1) return;
            if (msg._id === 33) update_pos(msg);
            else if (msg._id === 242) update_home(msg);
            else if (msg._id === 62) update_nav_target(msg);
            else if (msg._id === 87) update_position_target(msg);
        }

        // Appel régulier pour récupérer la dernière position
        setInterval(async () => {
            try {
                const response = await fetch('/drone-position');
                if (!response.ok) return;
                const msg = await response.json();
                update_pos(msg);
            } catch (e) {
                console.error("Erreur fetch position drone :", e);
            }
        }, 2000);

        function parseWaypoints(waypointsStr) {
            // Ex: "WP1: -154207169,497246178 WP2: ..."
            return waypointsStr.split("WP").slice(1).map(wp => {
                const [label, coords] = wp.split(":");
                const [lon, lat] = coords.trim().split(",").map(Number);
                return {
                    label: "WP" + label.trim(),
                    lat: lat / 1e7,
                    lon: lon / 1e7
                };
            });
        }

        // Exemple d’utilisation après avoir fetch les missions récentes
        fetch("/drone-missions/recent")
            .then(res => res.json())
            .then(missions => {
                missions.forEach(m => {
                    if (m.waypoints) {
                        const waypoints = parseWaypoints(m.waypoints);
                        // On extrait les coordonnées dans le bon format
                        const latlngs = waypoints.map(wp => [wp.lat, wp.lon]);
                        // On trace la route sur la carte
                        L.polyline(latlngs, {
                            color: "blue",
                            weight: 3,
                            opacity: 0.7
                        }).addTo(map);
                    }
                });
            });

    </script>
</body>
</html>
