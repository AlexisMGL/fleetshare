<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AerialMetric fleet follow</title>

    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #windy {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 0;
            border: none;
            border-radius: 0;
            background-color: #fff;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }

        #loading {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        #dashboard {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 1000;
        }

        #testRouteBtn {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 1000;
            padding: 6px 10px;
        }

        #testRouteModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #testRouteModalContent {
            background: white;
            padding: 20px;
            border-radius: 5px;
            max-width: 600px;
            width: 90%;
        }

    </style>
</head>
<body>
    <div id="windy"></div>
    <div id="loading">Loading</div>
    <div id="dashboard"></div>
    <button id="testRouteBtn">Test Route</button>
    <div id="testRouteModal">
        <div id="testRouteModalContent">
            <input type="file" id="routeFileInput" accept=".txt,.waypoint,.waypoints"><br/>
            <label>Heure de départ: <input type="time" id="departureTime"></label><br/>
            <button id="runTest">Lancer</button>
            <button id="closeModal">Fermer</button>
            <canvas id="routeChart" style="max-width:100%;height:300px;"></canvas>
            <div id="testResult" style="font-size:20px;margin-top:10px;"></div>
        </div>
    </div>

    <script>
        let windy_options = {
            key: 'SSUGxhvXMZUTgav1QfuYZG7smD3vaEPB',
            lat: 14,
            lon: -29,
            zoom: 15
        };

        let init_done = false;
        let map = null;
        let options = null;

        // Initialisation locale d'options si aucun message externe n'est reçu
        if (!options) {
            options = {
                key: windy_options.key,
                autoPan: true,
                trailLengthM: 10000
            };
        }

        function init() {
            if (!options) {
                setTimeout(init, 100);
                return;
            }
            const loading_div = document.getElementById("loading");
            if (!options.key) {
                loading_div.innerHTML = "Please set API key";
                setTimeout(init, 100);
                return;
            }
            if (!init_done) {
                windy_options.key = options.key;
                init_done = true;
                windyInit(windy_options, windyAPI => {
                    map = windyAPI.map;
                    fetchAndDrawMissions();
                    map.options.maxZoom = 17;
                    loading_div.style.display = "none";

                    // force le calque "wind"
                    windyAPI.store.set("overlay", "wind");

                    // attribution Windy.com
                    map.attributionControl.addAttribution(
                        'Données météo © <a href="https://www.windy.com" target="_blank">Windy.com</a>'
                    );

                    // redessiner et déclencher zoomend pour rafraîchir l’UI
                    setTimeout(() => {
                        map.invalidateSize();
                        map.fire("zoomend");
                    }, 500);

                    // cercles
                    L.circle([-23.3470407, 47.5962614], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-22.91202751744944, 44.528044921900346], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-19.672116, 47.314187], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                });
            }
            if (!map) {
                loading_div.innerHTML = "Waiting for map";
                setTimeout(init, 100);
                return;
            }
            loading_div.style.display = "none";

            const topLayer = L.tileLayer(
                'http://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                {
                    attribution: 'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping',
                    minZoom: 12,
                    maxZoom: 17
                }
            ).addTo(map);
            topLayer.setOpacity(0);
            map.on('zoomend', () => {
                topLayer.setOpacity(map.getZoom() >= 12 ? 1 : 0);
            });

            map.setView([-18.91368, 47.53613], 7);
            L.control.scale().addTo(map);
        }

        setTimeout(init, 100);

        // Add new vehicle to map
        let vehicle = [];
        let missionsData = {};
        let lastAirspeed = {};
        let lastGroundspeed = {};
        let lastWindspeed = {};

        function computeMissionInfo(pos, waypoints) {
            if (!waypoints || waypoints.length < 2) {
                return { progress: 0, totalKm: 0, remainingKm: 0 };
            }

            // Total distance of the mission
            let total = 0;
            const segStart = [0];
            for (let i = 1; i < waypoints.length; i++) {
                total += waypoints[i - 1].distanceTo(waypoints[i]);
                segStart[i] = total;
            }

            if (total === 0) {
                return { progress: 0, totalKm: 0, remainingKm: 0 };
            }

            // Find the closest point on the route to current position
            let bestDist = Infinity;
            let traveled = 0;
            for (let i = 1; i < waypoints.length; i++) {
                const A = waypoints[i - 1];
                const B = waypoints[i];
                const segLen = A.distanceTo(B);

                const abLat = B.lat - A.lat;
                const abLng = B.lng - A.lng;
                const ab2 = abLat * abLat + abLng * abLng;
                let t = 0;
                if (ab2 > 0) {
                    const apLat = pos.lat - A.lat;
                    const apLng = pos.lng - A.lng;
                    t = (apLat * abLat + apLng * abLng) / ab2;
                    t = Math.max(0, Math.min(1, t));
                }

                const proj = L.latLng(A.lat + abLat * t, A.lng + abLng * t);
                const distToSeg = pos.distanceTo(proj);
                if (distToSeg < bestDist) {
                    bestDist = distToSeg;
                    traveled = segStart[i - 1] + segLen * t;
                }
            }

            const remaining = Math.max(0, total - traveled);
            return {
                progress: (traveled / total) * 100,
                totalKm: total / 1000,
                remainingKm: remaining / 1000,
                traveledKm: traveled / 1000
            };
        }

        function updateDashboard() {
            const dash = document.getElementById('dashboard');
            const ids = Object.keys(vehicle);
            const flying = ids.filter(id => (lastAirspeed[id] || 0) > 10);
            let html = `<b>Drones en vol : ${flying.length}</b><br/>`;
            ids.forEach(id => {
                const pos = vehicle[id].marker.getLatLng();
                const wpts = missionsData[id];
                if (wpts) {
                    const info = computeMissionInfo(pos, wpts);
                    const pct = Math.round(info.progress);
                    const traveled = info.traveledKm.toFixed(1);
                    const total = info.totalKm.toFixed(1);
                    const sec = (info.remainingKm * 1000) / 25;
                    const landDate = new Date(Date.now() + sec * 1000);
                    const landStr = `${landDate.getHours().toString().padStart(2, '0')}:${landDate.getMinutes().toString().padStart(2, '0')}`;
                    html += `SN${id} : ${pct}% (${traveled}/${total} km) (land: ${landStr})<br/>`;
                } else {
                    html += `SN${id} : NA<br/>`;
                }
            });
            dash.innerHTML = html;
        }
        function vehicle_init(id, location, msg) {
            const vehicle_icon = L.divIcon({
                html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                   <path fill="#000" d="M482.3 192c34.2 0 93.7 29 93.7 64c0 36-59.5 64-93.7 64l-116.6 0L265.2 495.9c-5.7 10-16.3 16.1-27.8 16.1l-56.2 0c-10.6 0-18.3-10.2-15.4-20.4l49-171.6L112 320 68.8 377.6c-3 4-7.8 6.4-12.8 6.4l-42 0c-7.8 0-14-6.3-14-14c0-1.3 .2-2.6 .5-3.9L32 256 .5 145.9c-.4-1.3-.5-2.6-.5-3.9c0-7.8 6.3-14 14-14l42 0c5 0 9.8 2.4 12.8 6.4L112 192l102.9 0-49-171.6C162.9 10.2 170.6 0 181.2 0l56.2 0c11.5 0 22.1 6.2 27.8 16.1L365.7 192l116.6 0z"/>
                 </svg>`,
                className: "",
                iconSize: [50, 44]
            });
            const marker = new L.marker(location, {
                icon: vehicle_icon,
                rotationOrigin: "center",
                zIndexOffset: 10000,
                interactive: true
            }).addTo(map);

            // Tooltip permanent, une seule fois
            let tooltip = `SN${msg.sysid ?? id}`;
            marker.bindTooltip(tooltip, {
                permanent: true,
                direction: "right",
                offset: [20, 0],
                className: "vehicle-tooltip"
            });

            // Gestion du survol : change dynamiquement le contenu du tooltip
            marker.on('mouseover', function () {
                let hoverTooltip = `SN${msg.sysid ?? id}`;
                const as = lastAirspeed[id];
                const gs = lastGroundspeed[id];
                const ws = lastWindspeed[id];
                if (typeof as === 'number' && typeof gs === 'number' && typeof ws === 'number') {
                    hoverTooltip += `<br><span style="font-size:12px;">as = ${as} gs = ${gs} ws = ${ws}</span>`;
                } else if (typeof as === 'number' && typeof gs === 'number') {
                    hoverTooltip += `<br><span style="font-size:12px;">as = ${as} gs = ${gs}</span>`;
                }
                this.setTooltipContent(hoverTooltip);
            });
            marker.on('mouseout', function () {
                this.setTooltipContent(`SN${msg.sysid ?? id}`);
            });

            const trail = new L.polyline([location], {
                color: "yellow",
                interactive: false
            }).addTo(map);
            vehicle[id] = { marker, trail };
            map.panTo(location);
        }

        function update_pos(msg) {
            // Vérifie que lat et lon existent et sont des nombres
            if (typeof msg.lat !== "number" || typeof msg.lon !== "number") {
                console.warn("update_pos ignoré : lat/lon manquants", msg);
                return;
            }
            const id = msg.sysid ?? 1;
            const location = new L.LatLng(msg.lat, msg.lon);
            const heading = msg.yaw || 0;
            if (typeof msg.airspeed === 'number') {
                lastAirspeed[id] = msg.airspeed;
            }
            if (typeof msg.groundspeed === 'number') {
                lastGroundspeed[id] = msg.groundspeed;
            }
            if (typeof msg.windspeed === 'number') {
                lastWindspeed[id] = msg.windspeed;
            }
            if (!vehicle[id]) {
                vehicle_init(id, location, msg);
            }
            if ("setRotationAngle" in vehicle[id].marker) {
                vehicle[id].marker.setRotationAngle(heading - 90.0);
            }
            vehicle[id].marker.setLatLng(location);

            // Met à jour le contenu du tooltip en tenant compte du survol
            let tooltipContent = `SN${msg.sysid ?? id}`;
            const as = lastAirspeed[id];
            const gs = lastGroundspeed[id];
            const ws = lastWindspeed[id];
            const showDetails = vehicle[id].marker.isTooltipOpen && vehicle[id].marker.isTooltipOpen();
            if (showDetails && typeof as === 'number' && typeof gs === 'number' && typeof ws === 'number') {
                tooltipContent += `<br><span style="font-size:12px;">as = ${as} gs = ${gs} ws = ${ws}</span>`;
            } else if (showDetails && typeof as === 'number' && typeof gs === 'number') {
                tooltipContent += `<br><span style="font-size:12px;">as = ${as} gs = ${gs}</span>`;
            }
            vehicle[id].marker.setTooltipContent(tooltipContent);

            //if (options.autoPan) {
            //    map.panInside(location, { padding: [50, 50] });
            //}
            const trail = vehicle[id].trail.getLatLngs();
            trail.unshift(location);
            let length = 0;
            for (let i = 1; i < trail.length; i++) {
                length += trail[i - 1].distanceTo(trail[i]);
                if (length > options.trailLengthM) {
                    trail.splice(i);
                    break;
                }
            }
            vehicle[id].trail.setLatLngs(trail);
            updateDashboard();
        }


        // Add home to the map
        let home = [];
        function home_init(id, location) {
            const icon_div = document.createElement("div");
            icon_div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                                    <path fill="#fff" d="M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/>
                                 </svg>`;
            const home_icon = L.divIcon({ html: icon_div, className: "", iconSize: [40, 36] });
            home[id] = new L.marker(location, { icon: home_icon, interactive: false }).addTo(map);
        }
        function update_home(msg) {
            const id = msg._header.srcSystem;
            const location = new L.LatLng(msg.latitude * 1e-7, msg.longitude * 1e-7);
            if (!home[id]) home_init(id, location);
            home[id].setLatLng(location);
        }

        // Nav target line
        function update_nav_target(msg) { /* ... same as before ... */ }
        // Position target line
        function update_position_target(msg) { /* ... same as before ... */ }

        // Runtime function
        function handle_msg(msg) {
            if (!map || msg._header.srcComponent !== 1) return;
            if (msg._id === 33) update_pos(msg);
            else if (msg._id === 242) update_home(msg);
            else if (msg._id === 62) update_nav_target(msg);
            else if (msg._id === 87) update_position_target(msg);
        }

        // Appel régulier pour récupérer la dernière position
        setInterval(async () => {
            try {
                const response = await fetch('/drone-position');
                if (!response.ok) return;
                const msg = await response.json();
                update_pos(msg);
            } catch (e) {
                console.error("Erreur fetch position drone :", e);
            }
        }, 2000);

        function parseWaypoints(waypointsStr) {
            return waypointsStr.split("WP").slice(1).map(wp => {
                const [label, coords] = wp.split(":");
                const [lat, lon] = coords.trim().split(",").map(Number);
                return {
                    label: "WP" + label.trim(),
                    lat: lat / 1e7,
                    lon: lon / 1e7
                };
            });
        }

        function fetchAndDrawMissions() {
            fetch("/drone-missions/recent")
                .then(res => res.json())
                .then(missions => {
                    missions.forEach(m => {
                        if (m.waypoints) {
                            const waypoints = parseWaypoints(m.waypoints);
                            const latlngs = waypoints.map(wp => [wp.lat, wp.lon]);
                            missionsData[m.sysid] = latlngs.map(ll => L.latLng(ll[0], ll[1]));
                            if (latlngs.length > 1) {
                                const poly = L.polyline(latlngs, {
                                    color: "blue",
                                    weight: 3,
                                    opacity: 0.7
                                }).addTo(map);
                                // Ajoute ce zoom automatique :
                                map.fitBounds(poly.getBounds());
                            }
                        }
                    });
                    updateDashboard();
                });
        }

        // -------- Test Route logic ---------
        function parseQgcFile(text) {
            const lines = text.trim().split(/\r?\n/);
            const wpts = [];
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].trim().split(/\s+/);
                if (cols.length >= 11) {
                    wpts.push({
                        lat: parseFloat(cols[8]),
                        lon: parseFloat(cols[9]),
                        alt: parseFloat(cols[10])
                    });
                }
            }
            return wpts;
        }

        async function getElevation(lat, lon) {
            try {
                const r = await fetch(`https://api.opentopodata.org/v1/test-dataset?locations=${lat},${lon}`);
                const j = await r.json();
                return j.results[0].elevation;
            } catch (e) {
                console.error('elevation', e);
                return 0;
            }
        }

        function parseTime(str) {
            const [h, m] = str.split(':').map(Number);
            const d = new Date();
            d.setHours(h, m, 0, 0);
            return d.getTime();
        }

        async function getMaxGust(lat, lon, startTs, endTs) {
            const body = {
                lat,
                lon,
                model: 'gfs',
                parameters: ['windGust'],
                key: 'N3vTX5PijkaL9dg3rTIqj628Nw5gQqqu'
            };
            const res = await fetch('https://api.windy.com/api/point-forecast/v2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const data = await res.json();
            const times = data.ts || [];
            const gusts = data['gust-surface'] || [];
            let max = 0;
            for (let i = 0; i < times.length; i++) {
                if (times[i] >= startTs && times[i] <= endTs) {
                    const g = gusts[i];
                    if (g != null && g > max) max = g;
                }
            }
            return max;
        }

        async function runRouteTest() {
            const fileInput = document.getElementById('routeFileInput');
            if (!fileInput.files.length) { alert('Choisir un fichier'); return; }
            const text = await fileInput.files[0].text();
            const waypoints = parseQgcFile(text);
            if (!waypoints.length) { alert('Fichier invalide'); return; }
            const depTime = document.getElementById('departureTime').value;
            if (!depTime) { alert('Heure manquante'); return; }
            const startTs = parseTime(depTime);
            const endTs = startTs + 3 * 3600 * 1000;

            const baseAlt = await getElevation(waypoints[0].lat, waypoints[0].lon);
            const distances = [0];
            for (let i = 1; i < waypoints.length; i++) {
                const d = L.latLng(waypoints[i-1].lat, waypoints[i-1].lon)
                    .distanceTo([waypoints[i].lat, waypoints[i].lon]);
                distances[i] = distances[i-1] + d;
            }

            const gusts = [];
            for (const wp of waypoints) {
                const g = await getMaxGust(wp.lat, wp.lon, startTs, endTs);
                gusts.push(g);
            }

            const ctx = document.getElementById('routeChart').getContext('2d');
            if (window.routeChart) window.routeChart.destroy();
            window.routeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: distances.map(d => (d/1000).toFixed(1)),
                    datasets: [
                        {
                            label: 'Altitude (m)',
                            data: waypoints.map(w => w.alt),
                            borderColor: 'blue',
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Rafales (m/s)',
                            data: gusts,
                            borderColor: 'red',
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    scales: {
                        y1: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Altitude rel. (m)' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Rafales (m/s)' }
                        }
                    }
                }
            });

            const maxG = Math.max(...gusts);
            const result = document.getElementById('testResult');
            result.textContent = maxG < 9 ? 'OK' : 'NON';
            result.style.color = maxG < 9 ? 'green' : 'red';
        }

        document.getElementById('testRouteBtn').addEventListener('click', () => {
            document.getElementById('testRouteModal').style.display = 'flex';
        });
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('testRouteModal').style.display = 'none';
        });
        document.getElementById('runTest').addEventListener('click', runRouteTest);



    </script>
</body>
</html>
