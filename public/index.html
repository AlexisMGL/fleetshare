<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AerialMetric fleet follow</title>

    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #windy {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
        }

        #loading {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div id="windy"></div>
    <div id="loading">Loading</div>
</body>
<script>
    let windy_options = {
        key: 'SSUGxhvXMZUTgav1QfuYZG7smD3vaEPB',
        lat: 14,
        lon: -29,
        zoom: 15
    };

    let init_done = false;
    let map = null;
    let options = null;

    // Initialisation locale d'options si aucun message externe n'est reçu
    if (!options) {
        options = {
            key: windy_options.key,
            autoPan: true,
            trailLengthM: 10000
        };
    }

    function init() {
        if (!options) {
            setTimeout(init, 100);
            return;
        }
        const loading_div = document.getElementById("loading");
        if (!options.key) {
            loading_div.innerHTML = "Please set API key";
            setTimeout(init, 100);
            return;
        }
        if (!init_done) {
            windy_options.key = options.key;
            init_done = true;
            windyInit(windy_options, windyAPI => {
                map = windyAPI.map;
                map.options.maxZoom = 17;
                loading_div.style.display = "none";

                // force le calque "wind"
                windyAPI.store.set("overlay", "wind");

                // attribution Windy.com
                map.attributionControl.addAttribution(
                    'Données météo © <a href="https://www.windy.com" target="_blank">Windy.com</a>'
                );

                // redessiner et déclencher zoomend pour rafraîchir l’UI
                setTimeout(() => {
                    map.invalidateSize();
                    map.fire("zoomend");
                }, 500);

                // cercles
                L.circle([-23.3470407, 47.5962614], {
                    color: 'red',
                    fillOpacity: 0,
                    radius: 120000
                }).addTo(map);
                L.circle([-22.91202751744944, 44.528044921900346], {
                    color: 'blue',
                    fillOpacity: 0,
                    radius: 120000
                }).addTo(map);
                L.circle([-19.672116, 47.314187], {
                    color: 'green',
                    fillOpacity: 0,
                    radius: 120000
                }).addTo(map);
            });
        }
        if (!map) {
            loading_div.innerHTML = "Waiting for map";
            setTimeout(init, 100);
            return;
        }
        loading_div.style.display = "none";

        const topLayer = L.tileLayer(
            'http://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
            {
                attribution: 'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping',
                minZoom: 12,
                maxZoom: 17
            }
        ).addTo(map);
        topLayer.setOpacity(0);
        map.on('zoomend', () => {
            topLayer.setOpacity(map.getZoom() >= 12 ? 1 : 0);
        });

        map.setView([-18.91368, 47.53613], 7);
        L.control.scale().addTo(map);
    }

    setTimeout(init, 100);

    // Add new vehicle to map
    let vehicle = [];
    function vehicle_init(id, location, msg) {
        const vehicle_icon = L.divIcon({
            html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
           <path fill="#000" d="M482.3 192c34.2 0 93.7 29 93.7 64c0 36-59.5 64-93.7 64l-116.6 0L265.2 495.9c-5.7 10-16.3 16.1-27.8 16.1l-56.2 0c-10.6 0-18.3-10.2-15.4-20.4l49-171.6L112 320 68.8 377.6c-3 4-7.8 6.4-12.8 6.4l-42 0c-7.8 0-14-6.3-14-14c0-1.3 .2-2.6 .5-3.9L32 256 .5 145.9c-.4-1.3-.5-2.6-.5-3.9c0-7.8 6.3-14 14-14l42 0c5 0 9.8 2.4 12.8 6.4L112 192l102.9 0-49-171.6C162.9 10.2 170.6 0 181.2 0l56.2 0c11.5 0 22.1 6.2 27.8 16.1L365.7 192l116.6 0z"/>
         </svg>`,
            className: "",
            iconSize: [50, 44]
        });
        const marker = new L.marker(location, {
            icon: vehicle_icon,
            rotationOrigin: "center",
            zIndexOffset: 10000,
            interactive: true // important pour le survol
        }).addTo(map);

        // Tooltip permanent : seulement SNxx
        let tooltip = `SN${msg.sysid ?? id}`;
        marker.bindTooltip(tooltip, {
            permanent: true,
            direction: "right",
            offset: [20, 0],
            className: "vehicle-tooltip"
        });

        // Tooltip au survol : SNxx + as/gs
        let hoverTooltip = `SN${msg.sysid ?? id}`;
        if (msg.airspeed !== undefined && msg.groundspeed !== undefined) {
            hoverTooltip += `<br><span style="font-size:12px;">as = ${msg.airspeed} gs = ${msg.groundspeed}</span>`;
        }
        marker.bindTooltip(hoverTooltip, {
            permanent: false,
            direction: "right",
            offset: [20, 0],
            className: "vehicle-tooltip-hover"
        });

        // Affiche le tooltip au survol
        marker.on('mouseover', function (e) {
            this.openTooltip();
        });
        marker.on('mouseout', function (e) {
            this.closeTooltip();
        });

        const trail = new L.polyline([location], {
            color: "yellow",
            interactive: false
        }).addTo(map);
        vehicle[id] = { marker, trail };
        map.panTo(location);
    }

    // Update the position of a vehicle
    function update_pos(msg) {
        const id = msg.sysid ?? 1;
        const location = new L.LatLng(msg.lat, msg.lon);
        const heading = msg.yaw || 0;
        if (!vehicle[id]) {
            vehicle_init(id, location, msg);
        }
        if ("setRotationAngle" in vehicle[id].marker) {
            vehicle[id].marker.setRotationAngle(heading - 90.0);
        }
        vehicle[id].marker.setLatLng(location);

        // Texte de base pour le tooltip permanent
        let tooltip = `SN${msg.sysid ?? id}`;
        vehicle[id].marker.setTooltipContent(tooltip);

        // Gère le survol pour afficher plus d'infos
        vehicle[id].marker.off('mouseover');
        vehicle[id].marker.off('mouseout');
        vehicle[id].marker.on('mouseover', function () {
            let hoverTooltip = `SN${msg.sysid ?? id}`;
            if (msg.airspeed !== undefined && msg.groundspeed !== undefined) {
                hoverTooltip += `<br><span style="font-size:12px;">as = ${msg.airspeed} gs = ${msg.groundspeed}</span>`;
            }
            this.setTooltipContent(hoverTooltip);
        });
        vehicle[id].marker.on('mouseout', function () {
            this.setTooltipContent(tooltip);
        });

        if (options.autoPan) {
            map.panInside(location, { padding: [50, 50] });
        }
        const trail = vehicle[id].trail.getLatLngs();
        trail.unshift(location);
        let length = 0;
        for (let i = 1; i < trail.length; i++) {
            length += trail[i - 1].distanceTo(trail[i]);
            if (length > options.trailLengthM) {
                trail.splice(i);
                break;
            }
        }
        vehicle[id].trail.setLatLngs(trail);
    }

    // Add home to the map
    let home = [];
    function home_init(id, location) {
        const icon_div = document.createElement("div");
        icon_div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                            <path fill="#fff" d="M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/>
                         </svg>`;
        const home_icon = L.divIcon({ html: icon_div, className: "", iconSize: [40, 36] });
        home[id] = new L.marker(location, { icon: home_icon, interactive: false }).addTo(map);
    }
    function update_home(msg) {
        const id = msg._header.srcSystem;
        const location = new L.LatLng(msg.latitude * 1e-7, msg.longitude * 1e-7);
        if (!home[id]) home_init(id, location);
        home[id].setLatLng(location);
    }

    // Nav target line
    function update_nav_target(msg) { /* ... same as before ... */ }
    // Position target line
    function update_position_target(msg) { /* ... same as before ... */ }

    // Runtime function
    function handle_msg(msg) {
        if (!map || msg._header.srcComponent !== 1) return;
        if (msg._id === 33) update_pos(msg);
        else if (msg._id === 242) update_home(msg);
        else if (msg._id === 62) update_nav_target(msg);
        else if (msg._id === 87) update_position_target(msg);
    }

    // Appel régulier pour récupérer la dernière position
    setInterval(async () => {
        try {
            const response = await fetch('/drone-position');
            if (!response.ok) return;
            const msg = await response.json();
            update_pos(msg);
        } catch (e) {
            console.error("Erreur fetch position drone :", e);
        }
    }, 2000);
</script>
</html>
