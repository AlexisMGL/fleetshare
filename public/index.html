<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>AerialMetric fleet follow</title>

    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <script src="https://unpkg.com/leaflet-rotatedmarker@0.2.0/leaflet.rotatedMarker.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #windy {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 0;
            border: none;
            border-radius: 0;
            background-color: #fff;
            padding: 0;
            width: 100vw;
            height: 100vh;
        }

        #loading {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: 10px;
            border: 5px solid #c8c8c8;
            border-radius: 10px;
            background-color: #ffffff;
            padding: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 999;
        }

        #dashboard {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 1000;
        }

        #testRouteBtn {
            position: absolute;
            top: 70px; /* just below the dashboard */
            left: 10px;
            z-index: 1000;
            padding: 6px 10px;
        }

        #testRouteModal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        #testRouteModalContent {
            background: white;
            padding: 20px;
            border-radius: 5px;
            width: 95vw;
            height: 90vh;
            overflow-y: auto;
        }

        #testRouteModalContent input,
        #testRouteModalContent button {
            margin: 5px 0;
            padding: 4px 8px;
            font-size: 14px;
        }

        #progressContainer {
            display: none;
            position: relative;
            width: 100px;
            height: 100px;
            margin: 10px auto;
        }

        #progressContainer svg {
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        #progressPercent {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }

        .departure-label {
            font-weight: bold;
        }

        #departureTime {
            padding: 4px;
            border-radius: 4px;
        }

        #startTimeDisplay {
            text-align: center;
            margin-top: 5px;
            font-weight: bold;
        }

        #testResult {
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
            text-align: center;
        }

        #routeMap {
            width: 100%;
            height: 300px;
            margin-top: 10px;
            overflow: hidden;
            border: 1px solid #ccc;
        }

    </style>
</head>
<body>
    <div id="windy"></div>
    <div id="loading">Loading</div>
    <div id="dashboard"></div>
    <button id="testRouteBtn">Test Route</button>
    <div id="testRouteModal">
        <div id="testRouteModalContent">
            <input type="file" id="routeFileInput" accept=".txt,.waypoint,.waypoints"><br/>
            <label class="departure-label">Heure de départ: <input type="time" id="departureTime"></label><br/>
            <button id="runTest">Lancer</button>
            <button id="closeModal">Fermer</button>
            <div id="startTimeDisplay"></div>
            <div id="progressContainer">
                <svg width="100" height="100">
                    <circle cx="50" cy="50" r="45" stroke="#eee" stroke-width="10" fill="none"></circle>
                    <circle id="progressBar" cx="50" cy="50" r="45" stroke="#3498db" stroke-width="10" fill="none" stroke-linecap="round"></circle>
                </svg>
                <div id="progressPercent">0%</div>
            </div>
            <canvas id="routeChart1" style="max-width:100%;height:250px;"></canvas>
            <canvas id="routeChart2" style="max-width:100%;height:250px;"></canvas>
            <canvas id="routeChart3" style="max-width:100%;height:250px;"></canvas>
            <div id="routeMap" style="width:100%;height:300px;margin-top:10px;"></div>
            <div id="testResult" style="font-size:20px;margin-top:10px;"></div>
        </div>
    </div>

    <script>
        let windy_options = {
            key: 'SSUGxhvXMZUTgav1QfuYZG7smD3vaEPB',
            lat: 14,
            lon: -29,
            zoom: 15
        };

        let init_done = false;
        let map = null;
        let options = null;
        let testRouteMap = null;
        let testRoutePolyline = null;

        // Initialisation locale d'options si aucun message externe n'est reçu
        if (!options) {
            options = {
                key: windy_options.key,
                autoPan: true,
                trailLengthM: 10000
            };
        }

        function init() {
            if (!options) {
                setTimeout(init, 100);
                return;
            }
            const loading_div = document.getElementById("loading");
            if (!options.key) {
                loading_div.innerHTML = "Please set API key";
                setTimeout(init, 100);
                return;
            }
            if (!init_done) {
                windy_options.key = options.key;
                init_done = true;
                windyInit(windy_options, windyAPI => {
                    map = windyAPI.map;
                    fetchAndDrawMissions();
                    map.options.maxZoom = 17;
                    loading_div.style.display = "none";

                    // force le calque "wind"
                    windyAPI.store.set("overlay", "wind");

                    // attribution Windy.com
                    map.attributionControl.addAttribution(
                        'Données météo © <a href="https://www.windy.com" target="_blank">Windy.com</a>'
                    );

                    // redessiner et déclencher zoomend pour rafraîchir l’UI
                    setTimeout(() => {
                        map.invalidateSize();
                        map.fire("zoomend");
                    }, 500);

                    // cercles
                    L.circle([-23.3470407, 47.5962614], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-22.91202751744944, 44.528044921900346], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                    L.circle([-19.672116, 47.314187], {
                        color: 'blue',
                        fillOpacity: 0,
                        radius: 120000
                    }).addTo(map);
                });
            }
            if (!map) {
                loading_div.innerHTML = "Waiting for map";
                setTimeout(init, 100);
                return;
            }
            loading_div.style.display = "none";

            const topLayer = L.tileLayer(
                'http://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
                {
                    attribution: 'Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping',
                    minZoom: 12,
                    maxZoom: 17
                }
            ).addTo(map);
            topLayer.setOpacity(0);
            map.on('zoomend', () => {
                topLayer.setOpacity(map.getZoom() >= 12 ? 1 : 0);
            });

            map.setView([-18.91368, 47.53613], 7);
            L.control.scale().addTo(map);
        }

        setTimeout(init, 100);

        // Add new vehicle to map
        let vehicle = [];
        let missionsData = {};
        let lastAirspeed = {};
        let lastGroundspeed = {};
        let lastWindspeed = {};

        function computeMissionInfo(pos, waypoints) {
            if (!waypoints || waypoints.length < 2) {
                return { progress: 0, totalKm: 0, remainingKm: 0 };
            }

            // Total distance of the mission
            let total = 0;
            const segStart = [0];
            for (let i = 1; i < waypoints.length; i++) {
                total += waypoints[i - 1].distanceTo(waypoints[i]);
                segStart[i] = total;
            }

            if (total === 0) {
                return { progress: 0, totalKm: 0, remainingKm: 0 };
            }

            // Find the closest point on the route to current position
            let bestDist = Infinity;
            let traveled = 0;
            for (let i = 1; i < waypoints.length; i++) {
                const A = waypoints[i - 1];
                const B = waypoints[i];
                const segLen = A.distanceTo(B);

                const abLat = B.lat - A.lat;
                const abLng = B.lng - A.lng;
                const ab2 = abLat * abLat + abLng * abLng;
                let t = 0;
                if (ab2 > 0) {
                    const apLat = pos.lat - A.lat;
                    const apLng = pos.lng - A.lng;
                    t = (apLat * abLat + apLng * abLng) / ab2;
                    t = Math.max(0, Math.min(1, t));
                }

                const proj = L.latLng(A.lat + abLat * t, A.lng + abLng * t);
                const distToSeg = pos.distanceTo(proj);
                if (distToSeg < bestDist) {
                    bestDist = distToSeg;
                    traveled = segStart[i - 1] + segLen * t;
                }
            }

            const remaining = Math.max(0, total - traveled);
            return {
                progress: (traveled / total) * 100,
                totalKm: total / 1000,
                remainingKm: remaining / 1000,
                traveledKm: traveled / 1000
            };
        }

        function updateDashboard() {
            const dash = document.getElementById('dashboard');
            const ids = Object.keys(vehicle);
            const flying = ids.filter(id => (lastAirspeed[id] || 0) > 10);
            let html = `<b>Drones en vol : ${flying.length}</b><br/>`;
            ids.forEach(id => {
                const pos = vehicle[id].marker.getLatLng();
                const wpts = missionsData[id];
                if (wpts) {
                    const info = computeMissionInfo(pos, wpts);
                    const pct = Math.round(info.progress);
                    const traveled = info.traveledKm.toFixed(1);
                    const total = info.totalKm.toFixed(1);
                    const sec = (info.remainingKm * 1000) / 25;
                    const landDate = new Date(Date.now() + sec * 1000);
                    const landStr = `${landDate.getHours().toString().padStart(2, '0')}:${landDate.getMinutes().toString().padStart(2, '0')}`;
                    html += `SN${id} : ${pct}% (${traveled}/${total} km) (land: ${landStr})<br/>`;
                } else {
                    html += `SN${id} : NA<br/>`;
                }
            });
            dash.innerHTML = html;
        }
        function vehicle_init(id, location, msg) {
            const vehicle_icon = L.divIcon({
                html: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                   <path fill="#000" d="M482.3 192c34.2 0 93.7 29 93.7 64c0 36-59.5 64-93.7 64l-116.6 0L265.2 495.9c-5.7 10-16.3 16.1-27.8 16.1l-56.2 0c-10.6 0-18.3-10.2-15.4-20.4l49-171.6L112 320 68.8 377.6c-3 4-7.8 6.4-12.8 6.4l-42 0c-7.8 0-14-6.3-14-14c0-1.3 .2-2.6 .5-3.9L32 256 .5 145.9c-.4-1.3-.5-2.6-.5-3.9c0-7.8 6.3-14 14-14l42 0c5 0 9.8 2.4 12.8 6.4L112 192l102.9 0-49-171.6C162.9 10.2 170.6 0 181.2 0l56.2 0c11.5 0 22.1 6.2 27.8 16.1L365.7 192l116.6 0z"/>
                 </svg>`,
                className: "",
                iconSize: [50, 44]
            });
            const marker = new L.marker(location, {
                icon: vehicle_icon,
                rotationOrigin: "center",
                zIndexOffset: 10000,
                interactive: true
            }).addTo(map);

            // Tooltip permanent, une seule fois
            let tooltip = `SN${msg.sysid ?? id}`;
            marker.bindTooltip(tooltip, {
                permanent: true,
                direction: "right",
                offset: [20, 0],
                className: "vehicle-tooltip"
            });

            // Gestion du survol : change dynamiquement le contenu du tooltip
            marker.on('mouseover', function () {
                let hoverTooltip = `SN${msg.sysid ?? id}`;
                const as = lastAirspeed[id];
                const gs = lastGroundspeed[id];
                const ws = lastWindspeed[id];
                if (typeof as === 'number' && typeof gs === 'number' && typeof ws === 'number') {
                    hoverTooltip += `<br><span style="font-size:12px;">as = ${as} gs = ${gs} ws = ${ws}</span>`;
                } else if (typeof as === 'number' && typeof gs === 'number') {
                    hoverTooltip += `<br><span style="font-size:12px;">as = ${as} gs = ${gs}</span>`;
                }
                this.setTooltipContent(hoverTooltip);
            });
            marker.on('mouseout', function () {
                this.setTooltipContent(`SN${msg.sysid ?? id}`);
            });

            const trail = new L.polyline([location], {
                color: "yellow",
                interactive: false
            }).addTo(map);
            vehicle[id] = { marker, trail };
            map.panTo(location);
        }

        function update_pos(msg) {
            // Vérifie que lat et lon existent et sont des nombres
            if (typeof msg.lat !== "number" || typeof msg.lon !== "number") {
                console.warn("update_pos ignoré : lat/lon manquants", msg);
                return;
            }
            const id = msg.sysid ?? 1;
            const location = new L.LatLng(msg.lat, msg.lon);
            const heading = msg.yaw || 0;
            if (typeof msg.airspeed === 'number') {
                lastAirspeed[id] = msg.airspeed;
            }
            if (typeof msg.groundspeed === 'number') {
                lastGroundspeed[id] = msg.groundspeed;
            }
            if (typeof msg.windspeed === 'number') {
                lastWindspeed[id] = msg.windspeed;
            }
            if (!vehicle[id]) {
                vehicle_init(id, location, msg);
            }
            if ("setRotationAngle" in vehicle[id].marker) {
                vehicle[id].marker.setRotationAngle(heading - 90.0);
            }
            vehicle[id].marker.setLatLng(location);

            // Met à jour le contenu du tooltip en tenant compte du survol
            let tooltipContent = `SN${msg.sysid ?? id}`;
            const as = lastAirspeed[id];
            const gs = lastGroundspeed[id];
            const ws = lastWindspeed[id];
            const showDetails = vehicle[id].marker.isTooltipOpen && vehicle[id].marker.isTooltipOpen();
            if (showDetails && typeof as === 'number' && typeof gs === 'number' && typeof ws === 'number') {
                tooltipContent += `<br><span style="font-size:12px;">as = ${as} gs = ${gs} ws = ${ws}</span>`;
            } else if (showDetails && typeof as === 'number' && typeof gs === 'number') {
                tooltipContent += `<br><span style="font-size:12px;">as = ${as} gs = ${gs}</span>`;
            }
            vehicle[id].marker.setTooltipContent(tooltipContent);

            //if (options.autoPan) {
            //    map.panInside(location, { padding: [50, 50] });
            //}
            const trail = vehicle[id].trail.getLatLngs();
            trail.unshift(location);
            let length = 0;
            for (let i = 1; i < trail.length; i++) {
                length += trail[i - 1].distanceTo(trail[i]);
                if (length > options.trailLengthM) {
                    trail.splice(i);
                    break;
                }
            }
            vehicle[id].trail.setLatLngs(trail);
            updateDashboard();
        }


        // Add home to the map
        let home = [];
        function home_init(id, location) {
            const icon_div = document.createElement("div");
            icon_div.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">
                                    <path fill="#fff" d="M575.8 255.5c0 18-15 32.1-32 32.1l-32 0 .7 160.2c0 2.7-.2 5.4-.5 8.1l0 16.2c0 22.1-17.9 40-40 40l-16 0c-1.1 0-2.2 0-3.3-.1c-1.4 .1-2.8 .1-4.2 .1L416 512l-24 0c-22.1 0-40-17.9-40-40l0-24 0-64c0-17.7-14.3-32-32-32l-64 0c-17.7 0-32 14.3-32 32l0 64 0 24c0 22.1-17.9 40-40 40l-24 0-31.9 0c-1.5 0-3-.1-4.5-.2c-1.2 .1-2.4 .2-3.6 .2l-16 0c-22.1 0-40-17.9-40-40l0-112c0-.9 0-1.9 .1-2.8l0-69.7-32 0c-18 0-32-14-32-32.1c0-9 3-17 10-24L266.4 8c7-7 15-8 22-8s15 2 21 7L564.8 231.5c8 7 12 15 11 24z"/>
                                 </svg>`;
            const home_icon = L.divIcon({ html: icon_div, className: "", iconSize: [40, 36] });
            home[id] = new L.marker(location, { icon: home_icon, interactive: false }).addTo(map);
        }
        function update_home(msg) {
            const id = msg._header.srcSystem;
            const location = new L.LatLng(msg.latitude * 1e-7, msg.longitude * 1e-7);
            if (!home[id]) home_init(id, location);
            home[id].setLatLng(location);
        }

        // Nav target line
        function update_nav_target(msg) { /* ... same as before ... */ }
        // Position target line
        function update_position_target(msg) { /* ... same as before ... */ }

        // Runtime function
        function handle_msg(msg) {
            if (!map || msg._header.srcComponent !== 1) return;
            if (msg._id === 33) update_pos(msg);
            else if (msg._id === 242) update_home(msg);
            else if (msg._id === 62) update_nav_target(msg);
            else if (msg._id === 87) update_position_target(msg);
        }

        // Appel régulier pour récupérer la dernière position
        setInterval(async () => {
            try {
                const response = await fetch('/drone-position');
                if (!response.ok || response.status === 204) return;
                const msg = await response.json();
                update_pos(msg);
            } catch (e) {
                console.error("Erreur fetch position drone :", e);
            }
        }, 2000);

        function parseWaypoints(waypointsStr) {
            return waypointsStr.split("WP").slice(1).map(wp => {
                const [label, coords] = wp.split(":");
                const [lat, lon] = coords.trim().split(",").map(Number);
                return {
                    label: "WP" + label.trim(),
                    lat: lat / 1e7,
                    lon: lon / 1e7
                };
            });
        }

        function fetchAndDrawMissions() {
            fetch("/drone-missions/recent")
                .then(res => res.json())
                .then(missions => {
                    missions.forEach(m => {
                        if (m.waypoints) {
                            const waypoints = parseWaypoints(m.waypoints);
                            const latlngs = waypoints.map(wp => [wp.lat, wp.lon]);
                            missionsData[m.sysid] = latlngs.map(ll => L.latLng(ll[0], ll[1]));
                            if (latlngs.length > 1) {
                                const poly = L.polyline(latlngs, {
                                    color: "blue",
                                    weight: 3,
                                    opacity: 0.7
                                }).addTo(map);
                                // Ajoute ce zoom automatique :
                                map.fitBounds(poly.getBounds());
                            }
                        }
                    });
                    updateDashboard();
                });
        }

        // -------- Test Route logic ---------
        function parseQgcFile(text) {
            const lines = text.trim().split(/\r?\n/);
            const wpts = [];
            for (let i = 1; i < lines.length; i++) {
                const cols = lines[i].trim().split(/\s+/);
                if (cols.length >= 11 && parseInt(cols[3], 10) === 16) {
                    wpts.push({
                        lat: parseFloat(cols[8]),
                        lon: parseFloat(cols[9]),
                        alt: parseFloat(cols[10])
                    });
                }
            }
            return wpts;
        }

        async function getElevation(lat, lon) {
            try {
                const r = await fetch(`/elevation?lat=${lat}&lon=${lon}`);
                const j = await r.json();
                return j.elevation;
            } catch (e) {
                console.error('elevation', e);
                return 0;
            }
        }

        function parseTime(str) {
            const [h, m] = str.split(':').map(Number);
            const d = new Date();
            d.setHours(h, m, 0, 0);
            return d.getTime();
        }

        async function getForecastData(lat, lon, startTs, endTs) {
            const body = {
                lat,
                lon,
                model: 'gfs',
                parameters: [
                    'windGust',
                    'wind',
                    'temp',
                    'precip',
                    'lclouds',
                    'mclouds',
                    'hclouds'
                ],
                levels: ['surface'],
                key: 'N3vTX5PijkaL9dg3rTIqj628Nw5gQqqu'
            };

            const res = await fetch('https://api.windy.com/api/point-forecast/v2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!res.ok) {
                console.error('Windy API error', res.status, await res.text());
                return {
                    gust: 0,
                    wind: 0,
                    temp: 0,
                    precip: 0,
                    lclouds: 0,
                    mclouds: 0,
                    hclouds: 0
                };
            }

            const data = await res.json();
            const times = data.ts || [];
            const gusts = data['gust-surface'] || [];
            const wu = data['wind_u-surface'] || [];
            const wv = data['wind_v-surface'] || [];
            const temps = data['temp-surface'] || [];
            const precips = data['past3hprecip-surface'] || [];
            const lc = data['lclouds-surface'] || [];
            const mc = data['mclouds-surface'] || [];
            const hc = data['hclouds-surface'] || [];

            let maxGust = 0;
            let maxWind = 0;
            let maxTemp = -Infinity;
            let maxPrecip = 0;
            let maxLc = 0;
            let maxMc = 0;
            let maxHc = 0;

            for (let i = 0; i < times.length; i++) {
                if (times[i] >= startTs && times[i] <= endTs) {
                    const g = gusts[i];
                    if (g != null && g > maxGust) maxGust = g;

                    const u = wu[i];
                    const v = wv[i];
                    const w =
                        typeof u === 'number' && typeof v === 'number'
                            ? Math.sqrt(u * u + v * v)
                            : null;
                    if (w != null && w > maxWind) maxWind = w;

                    const t = temps[i];
                    if (t != null && t > maxTemp) maxTemp = t;

                    const p = precips[i];
                    if (p != null && p > maxPrecip) maxPrecip = p;

                    const l = lc[i];
                    if (l != null && l > maxLc) maxLc = l;

                    const m = mc[i];
                    if (m != null && m > maxMc) maxMc = m;

                    const h = hc[i];
                    if (h != null && h > maxHc) maxHc = h;
                }
            }

            return {
                gust: maxGust,
                wind: maxWind,
                temp: maxTemp,
                precip: maxPrecip,
                lclouds: maxLc,
                mclouds: maxMc,
                hclouds: maxHc
            };
        }

        async function runRouteTest() {
            const fileInput = document.getElementById('routeFileInput');
            if (!fileInput.files.length) { alert('Choisir un fichier'); return; }
            const text = await fileInput.files[0].text();
            const waypoints = parseQgcFile(text);
            if (!waypoints.length) { alert('Fichier invalide'); return; }
            const depTime = document.getElementById('departureTime').value;
            if (!depTime) { alert('Heure manquante'); return; }
            const startTs = parseTime(depTime);
            const endTs = startTs + 3 * 3600 * 1000;

            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('progressPercent');
            const startTimeDisplay = document.getElementById('startTimeDisplay');

            const radius = 45;
            const circumference = 2 * Math.PI * radius;
            progressBar.style.strokeDasharray = `${circumference}`;
            progressBar.style.strokeDashoffset = `${circumference}`;

            function setProgress(p) {
                const offset = circumference * (1 - p / 100);
                progressBar.style.strokeDashoffset = offset;
                progressPercent.textContent = `${p}%`;
            }

            progressContainer.style.display = 'block';
            setProgress(0);
            startTimeDisplay.textContent = `Départ à ${depTime.replace(':', 'h')}`;

            const totalSteps = waypoints.length + 2;
            let step = 0;
            const inc = () => { step++; setProgress(Math.min(100, Math.round(step / totalSteps * 100))); };

            const baseAlt = await getElevation(waypoints[0].lat, waypoints[0].lon);
            inc();
            const distances = [0];
            for (let i = 1; i < waypoints.length; i++) {
                const d = L.latLng(waypoints[i-1].lat, waypoints[i-1].lon)
                    .distanceTo([waypoints[i].lat, waypoints[i].lon]);
                distances[i] = distances[i-1] + d;
            }
            inc();

            const gusts = [];
            const winds = [];
            const temps = [];
            const precips = [];
            const lclouds = [];
            const mclouds = [];
            const hclouds = [];
            for (const wp of waypoints) {
                const f = await getForecastData(wp.lat, wp.lon, startTs, endTs);
                gusts.push(f.gust);
                winds.push(f.wind);
                temps.push(f.temp);
                precips.push(f.precip);
                lclouds.push(f.lclouds);
                mclouds.push(f.mclouds);
                hclouds.push(f.hclouds);
                inc();
            }

            const ctx1 = document.getElementById('routeChart1').getContext('2d');
            const ctx2 = document.getElementById('routeChart2').getContext('2d');
            const ctx3 = document.getElementById('routeChart3').getContext('2d');
            const labels = distances.map(d => (d/1000).toFixed(1));

            if (window.routeChart1 && typeof window.routeChart1.destroy === 'function') window.routeChart1.destroy();
            if (window.routeChart2 && typeof window.routeChart2.destroy === 'function') window.routeChart2.destroy();
            if (window.routeChart3 && typeof window.routeChart3.destroy === 'function') window.routeChart3.destroy();

            window.routeChart1 = new Chart(ctx1, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Altitude (m)',
                            data: waypoints.map(w => w.alt),
                            borderColor: 'blue',
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Rafales (m/s)',
                            data: gusts,
                            borderColor: 'red',
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Vent (m/s)',
                            data: winds,
                            borderColor: 'orange',
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Distance (km)' } },
                        y1: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Altitude rel. (m)' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Vent/Rafales (m/s)' }
                        }
                    }
                }
            });

            window.routeChart2 = new Chart(ctx2, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Altitude (m)',
                            data: waypoints.map(w => w.alt),
                            borderColor: 'blue',
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Précip. (mm)',
                            data: precips,
                            borderColor: 'green',
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Température (°C)',
                            data: temps,
                            borderColor: 'purple',
                            yAxisID: 'y3'
                        }
                    ]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Distance (km)' } },
                        y1: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Altitude rel. (m)' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            title: { display: true, text: 'Précip. (mm)' }
                        },
                        y3: {
                            type: 'linear',
                            position: 'right',
                            offset: true,
                            grid: { drawOnChartArea: false },
                            title: { display: true, text: 'Température (°C)' }
                        }
                    }
                }
            });

            window.routeChart3 = new Chart(ctx3, {
                type: 'line',
                data: {
                    labels,
                    datasets: [
                        {
                            label: 'Altitude (m)',
                            data: waypoints.map(w => w.alt),
                            borderColor: 'blue',
                            yAxisID: 'y1'
                        },
                        {
                            label: 'Low clouds (%)',
                            data: lclouds,
                            borderColor: 'brown',
                            yAxisID: 'y2'
                        },
                        {
                            label: 'Mid clouds (%)',
                            data: mclouds,
                            borderColor: 'gray',
                            yAxisID: 'y2'
                        },
                        {
                            label: 'High clouds (%)',
                            data: hclouds,
                            borderColor: 'black',
                            yAxisID: 'y2'
                        }
                    ]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Distance (km)' } },
                        y1: {
                            type: 'linear',
                            position: 'left',
                            title: { display: true, text: 'Altitude rel. (m)' }
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            min: 0,
                            max: 100,
                            title: { display: true, text: 'Nuages (%)' }
                        }
                    }
                }
            });

            const mapDiv = document.getElementById('routeMap');
            if (!testRouteMap) {
                testRouteMap = L.map(mapDiv, {
                    zoomControl: false,
                    attributionControl: false,
                    dragging: false,
                    scrollWheelZoom: false,
                    doubleClickZoom: false,
                    boxZoom: false,
                    keyboard: false,
                    touchZoom: false
                });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(testRouteMap);
            }
            if (testRoutePolyline) {
                testRouteMap.removeLayer(testRoutePolyline);
            }
            testRoutePolyline = L.polyline(waypoints.map(w => [w.lat, w.lon]), { color: 'red' }).addTo(testRouteMap);
            testRouteMap.fitBounds(testRoutePolyline.getBounds());
            testRouteMap.invalidateSize();

            const maxG = Math.max(...gusts);
            const result = document.getElementById('testResult');
            if (maxG < 9) {
                result.textContent = '✅ OK';
                result.style.color = 'green';
            } else {
                result.textContent = '❌ NON';
                result.style.color = 'red';
            }
            setProgress(100);
            progressContainer.style.display = 'none';
        }

        document.getElementById('testRouteBtn').addEventListener('click', () => {
            document.getElementById('testRouteModal').style.display = 'flex';
            if (testRouteMap) {
                setTimeout(() => testRouteMap.invalidateSize(), 0);
            }
        });
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('testRouteModal').style.display = 'none';
        });
        document.getElementById('runTest').addEventListener('click', runRouteTest);



    </script>
</body>
</html>
